<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Modbus Registers</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>
<!-- Generated by Doxygen 1.8.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__modbus__registers.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Modbus Registers</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7816677520b1eb2ebecf15060a41bc81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus__registers.html#ga7816677520b1eb2ebecf15060a41bc81">eMBRegInputCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNRegs)</td></tr>
<tr class="separator:ga7816677520b1eb2ebecf15060a41bc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d37e1d80224bf3b1eeb9e246d7582e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus__registers.html#ga10d37e1d80224bf3b1eeb9e246d7582e">eMBRegHoldingCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNRegs, <a class="el" href="group__modbus.html#gaf1398cbbeb317b1dbd0276b275f5b0f8">eMBRegisterMode</a> eMode)</td></tr>
<tr class="separator:ga10d37e1d80224bf3b1eeb9e246d7582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d9b719291515c60eee1bf9ffa1dd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus__registers.html#ga88d9b719291515c60eee1bf9ffa1dd02">eMBRegCoilsCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNCoils, <a class="el" href="group__modbus.html#gaf1398cbbeb317b1dbd0276b275f5b0f8">eMBRegisterMode</a> eMode)</td></tr>
<tr class="separator:ga88d9b719291515c60eee1bf9ffa1dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38101f5da54af137e210a3b8b9fa3887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__modbus__registers.html#ga38101f5da54af137e210a3b8b9fa3887">eMBRegDiscreteCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNDiscrete)</td></tr>
<tr class="separator:ga38101f5da54af137e210a3b8b9fa3887"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mb.h&quot;</span> </div>
</div><!-- fragment --><p> The protocol stack does not internally allocate any memory for the registers. This makes the protocol stack very small and also usable on low end targets. In addition the values don't have to be in the memory and could for example be stored in a flash.<br />
 Whenever the protocol stack requires a value it calls one of the callback function with the register address and the number of registers to read as an argument. The application should then read the actual register values (for example the ADC voltage) and should store the result in the supplied buffer.<br />
 If the protocol stack wants to update a register value because a write register function was received a buffer with the new register values is passed to the callback function. The function should then use these values to update the application register values. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga88d9b719291515c60eee1bf9ffa1dd02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBRegCoilsCB </td>
          <td>(</td>
          <td class="paramtype">UCHAR *&#160;</td>
          <td class="paramname"><em>pucRegBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT&#160;</td>
          <td class="paramname"><em>usAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT&#160;</td>
          <td class="paramname"><em>usNCoils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__modbus.html#gaf1398cbbeb317b1dbd0276b275f5b0f8">eMBRegisterMode</a>&#160;</td>
          <td class="paramname"><em>eMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used if a <em>Coil Register</em> value is read or written by the protocol stack. If you are going to use this function you might use the functions <a class="el" href="group__modbus__utils.html#gaffd1defb8bceb85f1b65d64fa1c895e1" title="Function to set bits in a byte buffer. ">xMBUtilSetBits(  )</a> and <a class="el" href="group__modbus__utils.html#ga94b3b43e1d2353e621748c79e2fb4dd5" title="Function to read bits in a byte buffer. ">xMBUtilGetBits(  )</a> for working with bitfields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pucRegBuffer</td><td>The bits are packed in bytes where the first coil starting at address <code>usAddress</code> is stored in the LSB of the first byte in the buffer <code>pucRegBuffer</code>. If the buffer should be written by the callback function unused coil values (I.e. if not a multiple of eight coils is used) should be set to zero. </td></tr>
    <tr><td class="paramname">usAddress</td><td>The first coil number. </td></tr>
    <tr><td class="paramname">usNCoils</td><td>Number of coil values requested. </td></tr>
    <tr><td class="paramname">eMode</td><td>If eMBRegisterMode::MB_REG_WRITE the application values should be updated from the values supplied in the buffer <code>pucRegBuffer</code>. If eMBRegisterMode::MB_REG_READ the application should store the current values in the buffer <code>pucRegBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function must return one of the following error codes:<ul>
<li>eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal Modbus response is sent.</li>
<li>eMBErrorCode::MB_ENOREG If the application does not map an coils within the requested address range. In this case a <b>ILLEGAL DATA ADDRESS</b> is sent as a response.</li>
<li>eMBErrorCode::MB_ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li>
<li>eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="AT91SAM7X_ROWLEY_2demo_8c-example.html#a11">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a10">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a14">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a10">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a12">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a11">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a9">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a12">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a14">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a12">WIN32TCP/demo.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga38101f5da54af137e210a3b8b9fa3887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBRegDiscreteCB </td>
          <td>(</td>
          <td class="paramtype">UCHAR *&#160;</td>
          <td class="paramname"><em>pucRegBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT&#160;</td>
          <td class="paramname"><em>usAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT&#160;</td>
          <td class="paramname"><em>usNDiscrete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used if a <em>Input Discrete Register</em> value is read by the protocol stack. </p>
<p>If you are going to use his function you might use the functions <a class="el" href="group__modbus__utils.html#gaffd1defb8bceb85f1b65d64fa1c895e1" title="Function to set bits in a byte buffer. ">xMBUtilSetBits(  )</a> and <a class="el" href="group__modbus__utils.html#ga94b3b43e1d2353e621748c79e2fb4dd5" title="Function to read bits in a byte buffer. ">xMBUtilGetBits(  )</a> for working with bitfields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pucRegBuffer</td><td>The buffer should be updated with the current coil values. The first discrete input starting at <code>usAddress</code> must be stored at the LSB of the first byte in the buffer. If the requested number is not a multiple of eight the remaining bits should be set to zero. </td></tr>
    <tr><td class="paramname">usAddress</td><td>The starting address of the first discrete input. </td></tr>
    <tr><td class="paramname">usNDiscrete</td><td>Number of discrete input values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function must return one of the following error codes:<ul>
<li>eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal Modbus response is sent.</li>
<li>eMBErrorCode::MB_ENOREG If no such discrete inputs exists. In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.</li>
<li>eMBErrorCode::MB_ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li>
<li>eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="AT91SAM7X_ROWLEY_2demo_8c-example.html#a12">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a11">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a15">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a11">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a13">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a12">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a10">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a13">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a15">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a13">WIN32TCP/demo.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga10d37e1d80224bf3b1eeb9e246d7582e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBRegHoldingCB </td>
          <td>(</td>
          <td class="paramtype">UCHAR *&#160;</td>
          <td class="paramname"><em>pucRegBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT&#160;</td>
          <td class="paramname"><em>usAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT&#160;</td>
          <td class="paramname"><em>usNRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__modbus.html#gaf1398cbbeb317b1dbd0276b275f5b0f8">eMBRegisterMode</a>&#160;</td>
          <td class="paramname"><em>eMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used if a <em>Holding Register</em> value is read or written by the protocol stack. The starting register address is given by <code>usAddress</code> and the last register is given by <code>usAddress + usNRegs - 1</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pucRegBuffer</td><td>If the application registers values should be updated the buffer points to the new registers values. If the protocol stack needs to now the current values the callback function should write them into this buffer. </td></tr>
    <tr><td class="paramname">usAddress</td><td>The starting address of the register. </td></tr>
    <tr><td class="paramname">usNRegs</td><td>Number of registers to read or write. </td></tr>
    <tr><td class="paramname">eMode</td><td>If eMBRegisterMode::MB_REG_WRITE the application register values should be updated from the values in the buffer. For example this would be the case when the Modbus master has issued an <b>WRITE SINGLE REGISTER</b> command. If the value eMBRegisterMode::MB_REG_READ the application should copy the current values into the buffer <code>pucRegBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function must return one of the following error codes:<ul>
<li>eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal Modbus response is sent.</li>
<li>eMBErrorCode::MB_ENOREG If the application can not supply values for registers within this range. In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.</li>
<li>eMBErrorCode::MB_ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li>
<li>eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="AT91SAM7X_ROWLEY_2demo_8c-example.html#a8">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a9">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a11">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a9">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a9">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a8">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a8">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a9">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a11">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a9">WIN32TCP/demo.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7816677520b1eb2ebecf15060a41bc81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBRegInputCB </td>
          <td>(</td>
          <td class="paramtype">UCHAR *&#160;</td>
          <td class="paramname"><em>pucRegBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT&#160;</td>
          <td class="paramname"><em>usAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT&#160;</td>
          <td class="paramname"><em>usNRegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used if the value of a <em>Input Register</em> is required by the protocol stack. The starting register address is given by <code>usAddress</code> and the last register is given by <code>usAddress + usNRegs - 1</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pucRegBuffer</td><td>A buffer where the callback function should write the current value of the modbus registers to. </td></tr>
    <tr><td class="paramname">usAddress</td><td>The starting address of the register. Input registers are in the range 1 - 65535. </td></tr>
    <tr><td class="paramname">usNRegs</td><td>Number of registers the callback function must supply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function must return one of the following error codes:<ul>
<li>eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal Modbus response is sent.</li>
<li>eMBErrorCode::MB_ENOREG If the application can not supply values for registers within this range. In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.</li>
<li>eMBErrorCode::MB_ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li>
<li>eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="AT91SAM7X_ROWLEY_2demo_8c-example.html#a5">AT91SAM7X_ROWLEY/demo.c</a>, <a class="el" href="AVR_2demo_8c-example.html#a6">AVR/demo.c</a>, <a class="el" href="LINUX_2demo_8c-example.html#a9">LINUX/demo.c</a>, <a class="el" href="MCF5235_2demo_8c-example.html#a6">MCF5235/demo.c</a>, <a class="el" href="MCF5235TCP_2demo_8c-example.html#a7">MCF5235TCP/demo.c</a>, <a class="el" href="MSP430_2demo_8c-example.html#a6">MSP430/demo.c</a>, <a class="el" href="STR71X_2simple2_8c-example.html#a5">STR71X/simple2.c</a>, <a class="el" href="STR71XTCP_2demo_8c-example.html#a7">STR71XTCP/demo.c</a>, <a class="el" href="WIN32_2demo_8cpp-example.html#a9">WIN32/demo.cpp</a>, and <a class="el" href="WIN32TCP_2demo_8cpp-example.html#a7">WIN32TCP/demo.cpp</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

<hr width="80%">
<p><center>Automatically generated by Doxygen 1.8.9.1 on Mon Oct 9 2017.</center></p>
</body>
</html>
